var documenterSearchIndex = {"docs":
[{"location":"api_reference.html#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api_reference.html#Setting-Parameters","page":"API Reference","title":"Setting Parameters","text":"","category":"section"},{"location":"api_reference.html","page":"API Reference","title":"API Reference","text":"To set parameters, use a DecodeParams object","category":"page"},{"location":"api_reference.html","page":"API Reference","title":"API Reference","text":"DecodeParams","category":"page"},{"location":"api_reference.html#SeqFISHSyndromeDecoding.DecodeParams","page":"API Reference","title":"SeqFISHSyndromeDecoding.DecodeParams","text":"DecodeParams()\n\nConstructor for DecodeParams object that sets default values for every parameter. Cost function parameters must be set by the user. If they are not, the decoding functions will throw an error.\n\n\n\n\n\n","category":"type"},{"location":"api_reference.html#Required-parameters","page":"API Reference","title":"Required parameters","text":"","category":"section"},{"location":"api_reference.html","page":"API Reference","title":"API Reference","text":"Users are required to set the some parameters for decoding using the following methods:","category":"page"},{"location":"api_reference.html","page":"API Reference","title":"API Reference","text":"set_xy_search_radius\nset_z_search_radius\nset_n_allowed_drops\nset_lat_var_cost_coeff\nset_z_var_cost_coeff\nset_lw_var_cost_coeff\nset_s_var_cost_coeff","category":"page"},{"location":"api_reference.html#SeqFISHSyndromeDecoding.set_xy_search_radius","page":"API Reference","title":"SeqFISHSyndromeDecoding.set_xy_search_radius","text":"set_xy_search_radius(prms :: DecodeParams, r :: Real)\n\nArguments\n\nprms: DecodeParams Object\nr: The lateral KDTree Search radius in pixels for aligned dots in previous barcoding blocks.\n\n\n\n\n\n","category":"function"},{"location":"api_reference.html#SeqFISHSyndromeDecoding.set_z_search_radius","page":"API Reference","title":"SeqFISHSyndromeDecoding.set_z_search_radius","text":"set_z_search_radius(prms :: DecodeParams, r :: Real)\n\nArguments\n\nprms: DecodeParams Object\nr: The z KDTree Search radius in slices for aligned dots in previous barcoding blocks.\n\n\n\n\n\n","category":"function"},{"location":"api_reference.html#SeqFISHSyndromeDecoding.set_n_allowed_drops","page":"API Reference","title":"SeqFISHSyndromeDecoding.set_n_allowed_drops","text":"set_n_allowed_drops(prms :: DecodeParams, d :: Integer)\n\nArguments\n\nprms: DecodeParams Object\nr: The number of allowed drops in a barcode. Only 0 and 1 are currently supported. The parity check matrix must have redundancy to support correcting for one drop, otherwise errors will occur.\n\n\n\n\n\n","category":"function"},{"location":"api_reference.html#SeqFISHSyndromeDecoding.set_lat_var_cost_coeff","page":"API Reference","title":"SeqFISHSyndromeDecoding.set_lat_var_cost_coeff","text":"set_lat_var_cost_coeff(prms :: DecodeParams, lvf :: Real)\n\nArguments\n\nprms: DecodeParams Object\nlvf: The lateral variance penalty coefficient in the cost function.\n\n\n\n\n\n","category":"function"},{"location":"api_reference.html#SeqFISHSyndromeDecoding.set_z_var_cost_coeff","page":"API Reference","title":"SeqFISHSyndromeDecoding.set_z_var_cost_coeff","text":"set_z_var_cost_coeff(prms :: DecodeParams, zvf :: Real)\n\nArguments\n\nprms: DecodeParams Object\nr: The z variance penalty coefficient in the cost function.\n\n\n\n\n\n","category":"function"},{"location":"api_reference.html#SeqFISHSyndromeDecoding.set_lw_var_cost_coeff","page":"API Reference","title":"SeqFISHSyndromeDecoding.set_lw_var_cost_coeff","text":"set_lw_var_cost_coeff(prms :: DecodeParams, lwvf :: Real)\n\nArguments\n\nprms: DecodeParams Object\nlwvf: The log weight variance penalty coefficient in the cost function.\n\n\n\n\n\n","category":"function"},{"location":"api_reference.html#SeqFISHSyndromeDecoding.set_s_var_cost_coeff","page":"API Reference","title":"SeqFISHSyndromeDecoding.set_s_var_cost_coeff","text":"set_s_var_cost_coeff(prms :: DecodeParams, sf :: Real)\n\nArguments\n\nprms: DecodeParams Object\nsvf: The σ variance penalty coefficient in the cost function.\n\n\n\n\n\n","category":"function"},{"location":"api_reference.html#Parameters-with-default-values","page":"API Reference","title":"Parameters with default values","text":"","category":"section"},{"location":"api_reference.html","page":"API Reference","title":"API Reference","text":"The rest of the parameters are given a default value by the DecodeParams Constructor, but may be set using the following methods:","category":"page"},{"location":"api_reference.html","page":"API Reference","title":"API Reference","text":"set_zeros_probed\nset_erasure_penalty\nset_free_dot_cost\nset_skip_thresh\nset_skip_density_thresh","category":"page"},{"location":"api_reference.html#SeqFISHSyndromeDecoding.set_zeros_probed","page":"API Reference","title":"SeqFISHSyndromeDecoding.set_zeros_probed","text":"set_zeros_probed(prms :: DecodeParams, zp :: Bool)\n\nArguments\n\nprms: DecodeParams Object\nzp: Whether or not zeros in codewords are probed in the experiment. Drops are not supported when false.\n\n\n\n\n\n","category":"function"},{"location":"api_reference.html#SeqFISHSyndromeDecoding.set_erasure_penalty","page":"API Reference","title":"SeqFISHSyndromeDecoding.set_erasure_penalty","text":"set_erasure_penalty(prms :: DecodeParams, ep :: Real)\n\nThe penalty that each dot dropped from a barcode adds to the cost function of the corrected barcode is ep. For example a barcode with one drop adds 1*ep to the cost of the barcode.\n\nArguments\n\nprms: DecodeParams Object\nep: penalty for decoding a barcode with a dropped dot\n\n\n\n\n\n","category":"function"},{"location":"api_reference.html#SeqFISHSyndromeDecoding.set_free_dot_cost","page":"API Reference","title":"SeqFISHSyndromeDecoding.set_free_dot_cost","text":"set_free_dot_cost(prms :: DecodeParams, fdc :: Real)\n\nArguments\n\nprms: DecodeParams Object\nfdc: The cost of not decoding a dot in the barcode candidate network\n\n\n\n\n\n","category":"function"},{"location":"api_reference.html#SeqFISHSyndromeDecoding.set_skip_thresh","page":"API Reference","title":"SeqFISHSyndromeDecoding.set_skip_thresh","text":"set_skip_thresh(prms :: DecodeParams, st :: Integer)\n\nArguments\n\nprms: DecodeParams Object\nst: conflicting networks of barcode candidates containing more barcode candidates than this threshold will be discarded.\n\n\n\n\n\n","category":"function"},{"location":"api_reference.html#SeqFISHSyndromeDecoding.set_skip_density_thresh","page":"API Reference","title":"SeqFISHSyndromeDecoding.set_skip_density_thresh","text":"set_skip_density_thresh(prms :: DecodeParams, sdt :: Real)\n\nArguments:\n\nprms: DecodeParams Object\nsdt: conflicting networks of barcode candidates that have a higher ratio of candidate barcodes to area of their bounding box in pixels than this threshold will be discarded.\n\n\n\n\n\n","category":"function"},{"location":"api_reference.html#Running-Decoding","page":"API Reference","title":"Running Decoding","text":"","category":"section"},{"location":"api_reference.html","page":"API Reference","title":"API Reference","text":"get_codepaths\nchoose_optimal_codepaths\ndecode_syndromes!","category":"page"},{"location":"api_reference.html#SeqFISHSyndromeDecoding.get_codepaths","page":"API Reference","title":"SeqFISHSyndromeDecoding.get_codepaths","text":"get_codepaths(pnts :: DataFrame, cb_df :: DataFrame, H :: Matrix, params :: DecodeParams)\n\nArguments\n\npnts: DataFrame of seqFISH psfs. Must include columns:\nx : x spatial coordinate of psfs\ny : y spatial coordinate of psfs\nz : z spatial coordinate of psfs\ns : the sigma width parameter of the psfs\nw : the weight (or brightness) of the psfs\nAdditionally, there the data frame must either have columns\nblock : the barcoding block in which the psf was found\npseudocolor : the pseudocolor of the barcoding block in which the psf was found\nor the block and pseudocolor can be computed from the hybridization\nhyb : the hybridization in which the dot was found\nwhere block = ceil(hyb / q), pseudocolor = (hyb - (block - 1) * q) % q, and q is the number of pseudocolors.\ncb : The codebook.\nH : The parity check Matrix\nparams : DecodeParams object holding the parameters for decoding\n\nComputes codepaths with syndrome decoding, removes codepaths that exceed the cost of not decoding their component dots, and and returns DataFrame of candidate codepaths.\n\n\n\n\n\nget_codepaths(pnts :: DataFrame, cb :: Matrix, H :: Matrix, params :: DecodeParams)\n\nComputes codepaths with syndrome decoding, removes codepaths that exceed the cost of not decoding their component dots, and returns DataFrame of candidate codepaths.\n\nArguments\n\npnts: DataFrame of seqFISH psfs. Must include columns:\nx : x spatial coordinate of psfs\ny : y spatial coordinate of psfs\nz : z spatial coordinate of psfs\ns : the sigma width parameter of the psfs\nw : the weight (or brightness) of the psfs\ncb : The codebook.\nH : The parity check Matrix\nparams : DecodeParams object holding the parameters for decoding\n\n\n\n\n\n","category":"function"},{"location":"api_reference.html#SeqFISHSyndromeDecoding.choose_optimal_codepaths","page":"API Reference","title":"SeqFISHSyndromeDecoding.choose_optimal_codepaths","text":"choose_optimal_codepaths(pnts :: DataFrame, cb_df :: DataFrame, H :: Matrix, params :: DecodeParams, cpath_df :: DataFrame, optimzer, ret_discarded :: Bool=false)\n\nArguments\n\npnts: DataFrame of seqFISH psfs. Must include columns:\nx : x spatial coordinate of psfs\ny : y spatial coordinate of psfs\nz : z spatial coordinate of psfs\ns : the sigma width parameter of the psfs\nw : the weight (or brightness) of the psfs\nAdditionally, there the data frame must either have columns\nblock : the barcoding block in which the psf was found\npseudocolor : the pseudocolor of the barcoding block in which the psf was found\nor the block and pseudocolor can be computed from the hybridization\nhyb : the hybridization in which the dot was found\nwhere block = ceil(hyb / q), pseudocolor = (hyb - (block - 1) * q) % q, and q is the number of pseudocolors.\ncb : The codebook.\nH : The parity check Matrix\nparams : DecodeParams object holding the parameters for decoding\ncpath_df : A DataFrame output from the get_codepaths function, defined above.\noptimizer : solver for integer linear programming optimizations. A list of supported solvers is available here\nret_discarded : if true, return data frame of candidate codepaths that were discarded for being in too large/too dense of a conflict network\n\nReturns\n\nDataFrame of decoded barcodes\nIf ret_discarded == True, returns second DataFrame of the codepaths discarded to density filters\n\nChoose best codepaths from previouly found candidates that may have been found with less strict parameters. Reevaluates the costs for each candidate and trims according to the passed parameters.\n\n\n\n\n\n","category":"function"},{"location":"api_reference.html#SeqFISHSyndromeDecoding.decode_syndromes!","page":"API Reference","title":"SeqFISHSyndromeDecoding.decode_syndromes!","text":"decode_syndromes!(\n    pnts :: DataFrame,\n    cb,\n    H :: Matrix,\n    params :: DecodeParams\n    optimizer = GLPK.Optimizer\n)\n\nArguments\n\npnts: DataFrame of seqFISH psfs. Must include columns:\nx : x spatial coordinate of psfs\ny : y spatial coordinate of psfs\nz : z spatial coordinate of psfs\ns : the sigma width parameter of the psfs\nw : the weight (or brightness) of the psfs\nAdditionally, there the data frame must either have columns\nblock : the barcoding block in which the psf was found\npseudocolor : the pseudocolor of the barcoding block in which the psf was found\nor the block and pseudocolor can be computed from the hybridization\nhyb : the hybridization in which the dot was found\nwhere block = ceil(hyb / q), pseudocolor = (hyb - (block - 1) * q) % q, and q is the number of pseudocolors.\ncb : The codebook.\nH : The parity check Matrix\nparams : DecodeParams object holding the parameters for decoding\noptimizer : solver for integer linear programming optimizations. Uses the open source GLPK optimizer by default, but allows faster commercial optimizers to be used if necessary.\n\nA list of supported solvers is available here\n\nTakes a DataFrame of aligned points with hyb, x, y, z, w, and s columns; codebook matix; parity check matrix (H); and DecodeParams stucture with decoding parameters set. Adds columns to input pnts matrix indicating the encoding block, syndrome component value, and decoding result indicated as the row of the codebook matrix matched to. Split up points into weakly connected components, then finds possible codeword messages and runs simulated annealing to assign them. The pnts dataframe should have hybridization, x, y, and z columns\n\n\n\n\n\n","category":"function"},{"location":"example_decode.html#Decoding-Example:-SeqFISH","page":"Decoding Example: SeqFISH+","title":"Decoding Example: SeqFISH+","text":"","category":"section"},{"location":"example_decode.html","page":"Decoding Example: SeqFISH+","title":"Decoding Example: SeqFISH+","text":"note: this example was generated using data and a jupyter notebook that are freely available at the SeqFISHSyndromeDecoding github repository","category":"page"},{"location":"example_decode.html","page":"Decoding Example: SeqFISH+","title":"Decoding Example: SeqFISH+","text":"using DataFrames\nusing CSV\nusing SeqFISHSyndromeDecoding\nusing GLPK","category":"page"},{"location":"example_decode.html","page":"Decoding Example: SeqFISH+","title":"Decoding Example: SeqFISH+","text":"This notebook shows demonstrates how to use SeqFISHSyndromeDecoding. The example data was taken from the 561 channel of cell number 8 in position 4 of replicate 2 of the 2019 SeqFISH+ NIH3T3 cell experiment. This particular subset of the data was chosen for its small size.","category":"page"},{"location":"example_decode.html","page":"Decoding Example: SeqFISH+","title":"Decoding Example: SeqFISH+","text":"First load the codebook that we will use to decode our sample data.","category":"page"},{"location":"example_decode.html","page":"Decoding Example: SeqFISH+","title":"Decoding Example: SeqFISH+","text":"cb = DataFrame(CSV.File(\"../example_data/codebook_ch_561.csv\"))\nprintln(first(cb, 5))","category":"page"},{"location":"example_decode.html","page":"Decoding Example: SeqFISH+","title":"Decoding Example: SeqFISH+","text":"5×5 DataFrame\n Row │ gene  block1  block2  block3  block4 \n     │ String31   Int64   Int64   Int64   Int64  \n─────┼───────────────────────────────────────────\n   1 │ Atp6v0e2       17      16      13       0\n   2 │ Pclo           14      14       4       4\n   3 │ Higd1a          0       1       1       0\n   4 │ Srrm1           6      14       4      16\n   5 │ Mapk8ip3       14      19      13       0","category":"page"},{"location":"example_decode.html","page":"Decoding Example: SeqFISH+","title":"Decoding Example: SeqFISH+","text":"Define the parity check matrix for the codebook","category":"page"},{"location":"example_decode.html","page":"Decoding Example: SeqFISH+","title":"Decoding Example: SeqFISH+","text":"H = [1 1 -1 -1;]","category":"page"},{"location":"example_decode.html","page":"Decoding Example: SeqFISH+","title":"Decoding Example: SeqFISH+","text":"1×4 Matrix{Int64}:\n 1  1  -1  -1","category":"page"},{"location":"example_decode.html","page":"Decoding Example: SeqFISH+","title":"Decoding Example: SeqFISH+","text":"We can verify that H is actually the parity check matrix of the codebook.","category":"page"},{"location":"example_decode.html","page":"Decoding Example: SeqFISH+","title":"Decoding Example: SeqFISH+","text":"all(H * Matrix(cb[:,2:end])' .% 20 .== 0)","category":"page"},{"location":"example_decode.html","page":"Decoding Example: SeqFISH+","title":"Decoding Example: SeqFISH+","text":"true","category":"page"},{"location":"example_decode.html","page":"Decoding Example: SeqFISH+","title":"Decoding Example: SeqFISH+","text":"Next we can load the aligned points from each hybridization for our example cell.","category":"page"},{"location":"example_decode.html","page":"Decoding Example: SeqFISH+","title":"Decoding Example: SeqFISH+","text":"pnts = DataFrame(CSV.File(\"../example_data/example_cell_points.csv\"))\nprintln(first(pnts, 5))","category":"page"},{"location":"example_decode.html","page":"Decoding Example: SeqFISH+","title":"Decoding Example: SeqFISH+","text":"5×5 DataFrame\n Row │ hyb    x        y        s        w        \n     │ Int64  Float64  Float64  Float64  Float64  \n─────┼────────────────────────────────────────────\n   1 │     1  767.664  1463.64     1.22   633.14\n   2 │     1  759.413  1534.17     1.22  1118.99\n   3 │     1  757.458  1501.22     1.22   866.506\n   4 │     1  808.817  1400.84     1.22  1292.37\n   5 │     1  804.688  1448.16     1.22  1734.99","category":"page"},{"location":"example_decode.html","page":"Decoding Example: SeqFISH+","title":"Decoding Example: SeqFISH+","text":"The SeqFISHSyndromeDecoding package requires that they hybridization column be UInt8s (to increase efficiency), and that there be a z column (for generality to 3d data)","category":"page"},{"location":"example_decode.html","page":"Decoding Example: SeqFISH+","title":"Decoding Example: SeqFISH+","text":"pnts.z = zeros(Float64, nrow(pnts))\npnts.hyb = UInt8.(pnts.hyb);","category":"page"},{"location":"example_decode.html","page":"Decoding Example: SeqFISH+","title":"Decoding Example: SeqFISH+","text":"Next we initialize a DecodeParams object, and set the parameters","category":"page"},{"location":"example_decode.html","page":"Decoding Example: SeqFISH+","title":"Decoding Example: SeqFISH+","text":"params = DecodeParams()\n\nset_lat_var_cost_coeff(params, 8.0)\nset_z_var_cost_coeff(params, 0.0)\nset_lw_var_cost_coeff(params, 3.2)\nset_s_var_cost_coeff(params, 0.0)\nset_free_dot_cost(params, 1.0)\n\nset_xy_search_radius(params, sqrt(size(H)[2]/6.0)*3)\nset_z_search_radius(params, 0.0);","category":"page"},{"location":"example_decode.html","page":"Decoding Example: SeqFISH+","title":"Decoding Example: SeqFISH+","text":"We can then decode","category":"page"},{"location":"example_decode.html","page":"Decoding Example: SeqFISH+","title":"Decoding Example: SeqFISH+","text":"barcodes = decode_syndromes!(pnts, cb, H, params)\nfirst(barcodes, 5)","category":"page"},{"location":"example_decode.html","page":"Decoding Example: SeqFISH+","title":"Decoding Example: SeqFISH+","text":"5×9 DataFrame\n Row │ gene  gene_number  cpath                      cost      x        y        z    cc     cc_size \n     │ String31?  Int64        Array…                     Float64   Any      Any      Any  Int64  Int64   \n─────┼────────────────────────────────────────────────────────────────────────────────────────────────────\n   1 │ Higd1a               3  [4000, 4203, 8632, 16480]  1.06754   990.275  1517.47  0.0   1406        1\n   2 │ Srrm1                4  [1133, 7101, 9168, 15521]  2.14305   764.521  1474.04  0.0     95        2\n   3 │ Srrm1                4  [1020, 7057, 9256, 15609]  1.17522   873.084  1535.57  0.0    390        1\n   4 │ Srrm1                4  [1177, 7120, 9365, 15689]  2.8198    882.568  1479.06  0.0    431        1\n   5 │ Srrm1                4  [1180, 7119, 9368, 15691]  0.241011  869.379  1540.38  0.0    432        1","category":"page"},{"location":"example_decode.html","page":"Decoding Example: SeqFISH+","title":"Decoding Example: SeqFISH+","text":"Alternatively, if we aren't sure what parameters we want to use, we can save time by splitting decode_syndromes! into its two steps. First we can identify barcode candidates with the get_codepaths (named for the paths that candidate barcodes take the the decoding graph in figure 1a) function using the least strict parameter set that we are interested in.","category":"page"},{"location":"example_decode.html","page":"Decoding Example: SeqFISH+","title":"Decoding Example: SeqFISH+","text":"candidates = get_codepaths(pnts, cb, H, params)\nprintln(first(candidates, 5))","category":"page"},{"location":"example_decode.html","page":"Decoding Example: SeqFISH+","title":"Decoding Example: SeqFISH+","text":"5×6 DataFrame\n Row │ cpath                       cost       gene_number  x        y        z   \n     │ Array…                      Any        Int64        Any      Any      Any \n─────┼───────────────────────────────────────────────────────────────────────────\n   1 │ [4034, 7497, 9354, 14834]   0.0322611          738  792.754  1543.43  0.0\n   2 │ [2479, 6290, 9655, 15972]   0.0770821         1300  876.973  1460.59  0.0\n   3 │ [1484, 8356, 10071, 16418]  0.0919919          271  884.483  1527.45  0.0\n   4 │ [1148, 7491, 11855, 13651]  0.139732          2287  833.953  1495.81  0.0\n   5 │ [2959, 6294, 8792, 13517]   0.168859          1755  845.245  1458.23  0.0","category":"page"},{"location":"example_decode.html","page":"Decoding Example: SeqFISH+","title":"Decoding Example: SeqFISH+","text":"We can then use the choose_optimal_codepaths function to find the same barcodew that we found earlier","category":"page"},{"location":"example_decode.html","page":"Decoding Example: SeqFISH+","title":"Decoding Example: SeqFISH+","text":"barcodes_again = choose_optimal_codepaths(pnts, cb, H, params, candidates, GLPK.Optimizer)\nbarcodes == barcodes_again","category":"page"},{"location":"example_decode.html","page":"Decoding Example: SeqFISH+","title":"Decoding Example: SeqFISH+","text":"true","category":"page"},{"location":"example_decode.html","page":"Decoding Example: SeqFISH+","title":"Decoding Example: SeqFISH+","text":"We can now also try choosing candidates using stricter parameters. This saves computation time by reducing the number of times that we have to run get_codepaths.","category":"page"},{"location":"example_decode.html","page":"Decoding Example: SeqFISH+","title":"Decoding Example: SeqFISH+","text":"strict_params = DecodeParams()\nset_lat_var_cost_coeff(strict_params, 12.0)\nset_z_var_cost_coeff(strict_params, 0.0)\nset_lw_var_cost_coeff(strict_params, 4.8)\nset_s_var_cost_coeff(strict_params, 0.0)\nset_free_dot_cost(strict_params, 1.0)\n\nset_xy_search_radius(strict_params, sqrt(size(H)[2]/6.0)*3)\nset_z_search_radius(strict_params, 0.0);\n\n\nstricter_barcodes = choose_optimal_codepaths(pnts, cb, H, strict_params, candidates, GLPK.Optimizer)\nprintln(first(stricter_barcodes, 5))","category":"page"},{"location":"example_decode.html","page":"Decoding Example: SeqFISH+","title":"Decoding Example: SeqFISH+","text":"5×9 DataFrame\n Row │ gene  gene_number  cpath                      cost      x        y        z    cc     cc_size \n     │ String31?  Int64        Array…                     Float64   Any      Any      Any  Int64  Int64   \n─────┼────────────────────────────────────────────────────────────────────────────────────────────────────\n   1 │ Higd1a               3  [4000, 4203, 8632, 16480]  1.60131   990.275  1517.47  0.0   1091        1\n   2 │ Srrm1                4  [1020, 7057, 9256, 15609]  1.76283   873.084  1535.57  0.0    291        1\n   3 │ Srrm1                4  [1133, 7101, 9168, 15521]  3.21457   764.521  1474.04  0.0    312        1\n   4 │ Srrm1                4  [1180, 7119, 9368, 15691]  0.361517  869.379  1540.38  0.0    326        1\n   5 │ Wbp11                7  [3862, 7010, 9228, 14463]  1.26753   777.584  1569.5   0.0   1049        1","category":"page"},{"location":"example_decode.html","page":"Decoding Example: SeqFISH+","title":"Decoding Example: SeqFISH+","text":"We can compare the decoding results using the two different sets of parameters.","category":"page"},{"location":"example_decode.html","page":"Decoding Example: SeqFISH+","title":"Decoding Example: SeqFISH+","text":"println(\"Number of gene encoding barcodes: \", sum(barcodes.gene .!= \"negative_control\"))\nestimated_false_discovery_rate = sum(barcodes.gene .== \"negative_control\")*sum(cb.gene .!= \"negative_control\")/sum(cb.gene .== \"negative_control\")/sum(barcodes.gene .!= \"negative_control\")\nprintln(\"Estimated False Discovery rate: \", estimated_false_discovery_rate)","category":"page"},{"location":"example_decode.html","page":"Decoding Example: SeqFISH+","title":"Decoding Example: SeqFISH+","text":"Number of gene encoding barcodes: 1474\nEstimated False Discovery rate: 0.024709855479406056","category":"page"},{"location":"example_decode.html","page":"Decoding Example: SeqFISH+","title":"Decoding Example: SeqFISH+","text":"println(\"Number of gene encoding barcodes: \", sum(stricter_barcodes.gene .!= \"negative_control\"))\nestimated_false_discovery_rate = sum(stricter_barcodes.gene .== \"negative_control\")*sum(cb.gene .!= \"negative_control\")/sum(cb.gene .== \"negative_control\")/sum(stricter_barcodes.gene .!= \"negative_control\")\nprintln(\"Estimated False Discovery rate: \", estimated_false_discovery_rate)","category":"page"},{"location":"example_decode.html","page":"Decoding Example: SeqFISH+","title":"Decoding Example: SeqFISH+","text":"Number of gene encoding barcodes: 1118\nEstimated False Discovery rate: 0.015330875292705262","category":"page"},{"location":"example_decode.html","page":"Decoding Example: SeqFISH+","title":"Decoding Example: SeqFISH+","text":"The less strict parameter set decodes about 40% more gene encoding barcodes at a cost of having twice the estimated false discovery rate. Since the estimated false discovery rate is still small, it is probably an acceptable trade off.","category":"page"},{"location":"example_decode.html","page":"Decoding Example: SeqFISH+","title":"Decoding Example: SeqFISH+","text":"To save your results, use the CSV.write command.","category":"page"},{"location":"example_decode.html","page":"Decoding Example: SeqFISH+","title":"Decoding Example: SeqFISH+","text":"CSV.write(\"example_results.csv\", barcodes)","category":"page"},{"location":"example_decode.html","page":"Decoding Example: SeqFISH+","title":"Decoding Example: SeqFISH+","text":"\"example_results.csv\"","category":"page"},{"location":"installation.html#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"installation.html","page":"Installation","title":"Installation","text":"To install, from the julia REPL run:","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"julia> using Pkg\njulia> Pkg.add(url=\"https://github.com/CaiGroup/SeqFISHSyndromeDecoding\")","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"Alternatively, open the package manager by typing","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"julia>] ","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"then","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"Pkg> add \"https://github.com/CaiGroup/SeqFISHSyndromeDecoding\"","category":"page"},{"location":"example_decode_RS.html#Decoding-Example:-Reed-Solomon-Codes","page":"Decoding Example: Reed-Solomon Codes","title":"Decoding Example: Reed-Solomon Codes","text":"","category":"section"},{"location":"example_decode_RS.html","page":"Decoding Example: Reed-Solomon Codes","title":"Decoding Example: Reed-Solomon Codes","text":"note: this example was generated using data and a jupyter notebook that are freely available at the SeqFISHSyndromeDecoding github repository","category":"page"},{"location":"example_decode_RS.html","page":"Decoding Example: Reed-Solomon Codes","title":"Decoding Example: Reed-Solomon Codes","text":"using Pkg\nPkg.activate(\".\")\nPkg.instantiate()\nusing DataFrames\nusing CSV\nusing SeqFISHSyndromeDecoding\nusing GLPK\nusing DelimitedFiles","category":"page"},{"location":"example_decode_RS.html","page":"Decoding Example: Reed-Solomon Codes","title":"Decoding Example: Reed-Solomon Codes","text":"This notebook shows demonstrates how to use SeqFISHSyndromeDecoding.jl. The smallest cell with the fewest dots in our Reed-Solomon encoded experiment, chosen for computational convienience. We also reduce computation time by using the highest lateral position variance reported in our manuscript with half the search radius used in the manuscript computations. The larger positional variance penalty would prohibit most additional candidate barcodes found with larger search radius.","category":"page"},{"location":"example_decode_RS.html","page":"Decoding Example: Reed-Solomon Codes","title":"Decoding Example: Reed-Solomon Codes","text":"First, load the codebook that we will use to decode our sample data.","category":"page"},{"location":"example_decode_RS.html","page":"Decoding Example: Reed-Solomon Codes","title":"Decoding Example: Reed-Solomon Codes","text":"cb = DataFrame(CSV.File(\"../example_data/full_RS_q11_k7_half_pool_cb.csv\"))\nprintln(first(cb, 5))","category":"page"},{"location":"example_decode_RS.html","page":"Decoding Example: Reed-Solomon Codes","title":"Decoding Example: Reed-Solomon Codes","text":"DataFrame\nRow  │ gene      block1  block2  block3  block4  block5  block6  block7  block8  block9  block10 \n     │ String31  Int64   Int64   Int64   Int64   Int64   Int64   Int64   Int64   Int64   Int64   \n─────┼───────────────────────────────────────────────────────────────────────────────────────────\n   1 │ Aars           2       8       5       0       0       0       0       0       2        0\n   2 │ Aco2          10       7       0       0       0       0       8       0       0        6\n   3 │ Actn4          9       7       0       0       9       2       0       0       0        0\n   4 │ Aebp1          2       0       1       3       0       0       0       2       0        0\n   5 │ Aqp1          10       0       3       0       0       0       9       1       0        0","category":"page"},{"location":"example_decode_RS.html","page":"Decoding Example: Reed-Solomon Codes","title":"Decoding Example: Reed-Solomon Codes","text":"Define the parity check matrix for the codebook","category":"page"},{"location":"example_decode_RS.html","page":"Decoding Example: Reed-Solomon Codes","title":"Decoding Example: Reed-Solomon Codes","text":"H = readdlm(\"../example_data/RS_q11_k7_H.csv\", ',', UInt8)","category":"page"},{"location":"example_decode_RS.html","page":"Decoding Example: Reed-Solomon Codes","title":"Decoding Example: Reed-Solomon Codes","text":"3×10 Matrix{UInt8}:\n 0x02  0x04  0x08  0x05  0x0a  0x09  0x07  0x03  0x06  0x01\n 0x04  0x05  0x09  0x03  0x01  0x04  0x05  0x09  0x03  0x01\n 0x08  0x09  0x06  0x04  0x0a  0x03  0x02  0x05  0x07  0x01","category":"page"},{"location":"example_decode_RS.html","page":"Decoding Example: Reed-Solomon Codes","title":"Decoding Example: Reed-Solomon Codes","text":"We can verify that H is actually the parity check matrix of the codebook.","category":"page"},{"location":"example_decode_RS.html","page":"Decoding Example: Reed-Solomon Codes","title":"Decoding Example: Reed-Solomon Codes","text":"all(H * Matrix(cb[:,2:end])' .% 11 .== 0)","category":"page"},{"location":"example_decode_RS.html","page":"Decoding Example: Reed-Solomon Codes","title":"Decoding Example: Reed-Solomon Codes","text":"true","category":"page"},{"location":"example_decode_RS.html","page":"Decoding Example: Reed-Solomon Codes","title":"Decoding Example: Reed-Solomon Codes","text":"Next we can load the aligned points from each hybridization for our example cell.","category":"page"},{"location":"example_decode_RS.html","page":"Decoding Example: Reed-Solomon Codes","title":"Decoding Example: Reed-Solomon Codes","text":"pnts = DataFrame(CSV.File(\"../example_data/example_RS_cell_points.csv\"))\nfilter!(pnt -> ~ismissing(pnt.pseudocolor), pnts)\npnts.block = UInt8.(pnts.block)\nselect!(pnts, Not([:ch,:hyb]))\nSeqFISHSyndromeDecoding.sort_readouts!(pnts)\nprintln(first(pnts, 5))","category":"page"},{"location":"example_decode_RS.html","page":"Decoding Example: Reed-Solomon Codes","title":"Decoding Example: Reed-Solomon Codes","text":"DataFrame\nRow  │ Column1  x        y        s        w        z        pos    pseudocolor  block  cellid \n     │ Int64    Float64  Float64  Float64  Float64  Float64  Int64  Float64?     UInt8  Int64  \n─────┼─────────────────────────────────────────────────────────────────────────────────────────\n   1 │       0   94.938  1884.65  1.21555  267.268      0.0      6          1.0      1       6\n   2 │    3815  105.651  1873.63  1.32669  253.041      0.0      6          1.0      1       6\n   3 │       8  109.834  1836.6   2.0      304.417      0.0      6          1.0      1       6\n   4 │      26  110.489  1873.2   1.47603  884.79       0.0      6          1.0      1       6\n   5 │      33  110.8    1885.17  1.50077  571.21       0.0      6          1.0      1       6","category":"page"},{"location":"example_decode_RS.html","page":"Decoding Example: Reed-Solomon Codes","title":"Decoding Example: Reed-Solomon Codes","text":"Next we initialize a DecodeParams object, and set the parameters","category":"page"},{"location":"example_decode_RS.html","page":"Decoding Example: Reed-Solomon Codes","title":"Decoding Example: Reed-Solomon Codes","text":"params = DecodeParams()\n\nset_zeros_probed(params, false)\nset_lat_var_cost_coeff(params, 7.0)\nset_z_var_cost_coeff(params, 0.0)\nset_lw_var_cost_coeff(params, 0.0)\nset_s_var_cost_coeff(params, 0.0)\nset_free_dot_cost(params, 1.0)\nset_n_allowed_drops(params, 0)\n\nset_xy_search_radius(params, 2)\nset_z_search_radius(params, 0.0);","category":"page"},{"location":"example_decode_RS.html","page":"Decoding Example: Reed-Solomon Codes","title":"Decoding Example: Reed-Solomon Codes","text":"We can then decode","category":"page"},{"location":"example_decode_RS.html","page":"Decoding Example: Reed-Solomon Codes","title":"Decoding Example: Reed-Solomon Codes","text":"barcodes = decode_syndromes!(pnts, cb, H, params);\nprintln(first(barcodes, 5))","category":"page"},{"location":"example_decode_RS.html","page":"Decoding Example: Reed-Solomon Codes","title":"Decoding Example: Reed-Solomon Codes","text":" DataFrame\n Row │ gene              gene_number  cpath                         cost      x        y        z    cc     cc_size \n     │ String31?         Any         Any                          Float64  Any     Any     Any Int64 Int64   \n─────┼──────────────────────────────────────────────────────────────────────────────────────────────────────────────\n   1 │ St13              220          [7127, 9160, 11942, 13432]    0.209086  114.12   1890.67  0.0      1       11\n   2 │ Ybx1              263          [13625, 16733, 21893, 24052]  0.621507  113.441  1891.12  0.0      1       11\n   3 │ negative_control  299          [6, 7923, 10905, 16128]       0.790891  110.843  1889.99  0.0      1       11\n   4 │ Msn               112          [5598, 7267, 19024, 23060]    3.25967   111.708  1890.39  0.0      1       11\n   5 │ Rarg              179          [11, 4496, 16538, 22858]      1.42675   114.981  1918.55  0.0      2        1","category":"page"},{"location":"example_decode_RS.html","page":"Decoding Example: Reed-Solomon Codes","title":"Decoding Example: Reed-Solomon Codes","text":"Alternatively, if we aren't sure what parameters we want to use, we can save time by splitting decodesyndromes! into its two steps. First we can identify barcode candidates with the ```getcodepaths``` (named for the paths that candidate barcodes take the the decoding graph in figure 1a) function using the least strict parameter set that we are interested in.","category":"page"},{"location":"example_decode_RS.html","page":"Decoding Example: Reed-Solomon Codes","title":"Decoding Example: Reed-Solomon Codes","text":"candidates = get_codepaths(pnts, cb, H, params);\nprintln(first(candidates, 5))\n","category":"page"},{"location":"example_decode_RS.html","page":"Decoding Example: Reed-Solomon Codes","title":"Decoding Example: Reed-Solomon Codes","text":"1m5×7 DataFrame\nRow  │ gene              gene_number  cpath                        cost      x        y        z  \n     │ String31?         Any          Any                          Any       Any      Any      Any\n─────┼─────────────────────────────────────────────────────────────────────────────────────────────\n   1 │ Ercc1             40           [4965, 12136, 16528, 19370]  0.286652  106.317  1843.72  0.0\n   2 │ Vim               261          [9474, 14973, 16125, 21132]  0.651009  108.019  1846.97  0.0\n   3 │ Ercc1             40           [4971, 12138, 16529, 19371]  1.27286   108.758  1849.4   0.0\n   4 │ negative_control  971          [763, 4117, 6469, 19371]     3.28321   108.719  1849.74  0.0\n   5 │ Slc38a2           209          [1571, 7619, 12630, 14130]   1.16154   108.261  1854.62  0.0","category":"page"},{"location":"example_decode_RS.html","page":"Decoding Example: Reed-Solomon Codes","title":"Decoding Example: Reed-Solomon Codes","text":"We can then use the choose_optimal_codepaths function to find the same barcodew that we found earlier","category":"page"},{"location":"example_decode_RS.html","page":"Decoding Example: Reed-Solomon Codes","title":"Decoding Example: Reed-Solomon Codes","text":"barcodes_again = choose_optimal_codepaths(pnts, cb, H, params, candidates, GLPK.Optimizer)\nbarcodes == barcodes_again","category":"page"},{"location":"example_decode_RS.html","page":"Decoding Example: Reed-Solomon Codes","title":"Decoding Example: Reed-Solomon Codes","text":"true","category":"page"},{"location":"example_decode_RS.html","page":"Decoding Example: Reed-Solomon Codes","title":"Decoding Example: Reed-Solomon Codes","text":"We can now also try choosing candidates using stricter parameters. This saves computation time by reducing the number of times that we have to run get_codepaths.","category":"page"},{"location":"example_decode_RS.html","page":"Decoding Example: Reed-Solomon Codes","title":"Decoding Example: Reed-Solomon Codes","text":"strict_params = DecodeParams()\n\nset_zeros_probed(strict_params, false)\nset_lat_var_cost_coeff(strict_params, 10.0)\nset_z_var_cost_coeff(strict_params, 0.0)\nset_lw_var_cost_coeff(strict_params, 0.0)\nset_s_var_cost_coeff(strict_params, 0.0)\nset_free_dot_cost(strict_params, 1.0)\nset_n_allowed_drops(strict_params, 0)\n\nset_xy_search_radius(strict_params, 2)\nset_z_search_radius(strict_params, 0.0);\n\nstricter_barcodes = choose_optimal_codepaths(pnts, cb, H, strict_params, candidates, GLPK.Optimizer)\nprintln(first(stricter_barcodes, 5))","category":"page"},{"location":"example_decode_RS.html","page":"Decoding Example: Reed-Solomon Codes","title":"Decoding Example: Reed-Solomon Codes","text":"DataFrame\n Row │ gene              gene_number  cpath                      cost      x        y        z    cc     cc_size\n     │ String31?         Any          Any                        Float64   Any      Any      Any  Int64  Int64   \n─────┼───────────────────────────────────────────────────────────────────────────────────────────────────────────\n   1 │ negative_control  299          [6, 7923, 10905, 16128]    1.12984   110.843  1889.99  0.0      1        2\n   2 │ Rarg              179          [11, 4496, 16538, 22858]   2.03821   114.981  1918.55  0.0      2        1\n   3 │ Khdrbs1           73           [13, 15343, 19604, 23071]  0.231704  117.603  1892.83  0.0      3        1\n   4 │ Spp1              214          [18, 10922, 11844, 14141]  2.79514   119.057  1867.67  0.0      4        1\n   5 │ Spp1              214          [19, 10921, 11846, 14142]  2.42644   119.15   1862.08  0.0      5        2","category":"page"},{"location":"example_decode_RS.html","page":"Decoding Example: Reed-Solomon Codes","title":"Decoding Example: Reed-Solomon Codes","text":"We can compare the decoding results using the two different sets of parameters. For brevity, we use gene encoding barcodes found in decoding runs that include searches for negative control barcodes, which differs from the procedure described in our manuscript in which datasets are also decoded with the negative control codewords ommitted from the codebook.","category":"page"},{"location":"example_decode_RS.html","page":"Decoding Example: Reed-Solomon Codes","title":"Decoding Example: Reed-Solomon Codes","text":"println(\"Number of gene encoding barcodes: \", sum(barcodes.gene .!= \"negative_control\"))\nestimated_false_discovery_rate = sum(barcodes.gene .== \"negative_control\")*sum(cb.gene .!= \"negative_control\")/sum(cb.gene .== \"negative_control\")/sum(barcodes.gene .!= \"negative_control\")\nprintln(\"Estimated False Discovery rate: \", estimated_false_discovery_rate)","category":"page"},{"location":"example_decode_RS.html","page":"Decoding Example: Reed-Solomon Codes","title":"Decoding Example: Reed-Solomon Codes","text":"Number of gene encoding barcodes: 1737\nEstimated False Discovery rate: 0.01654845665984571","category":"page"},{"location":"example_decode_RS.html","page":"Decoding Example: Reed-Solomon Codes","title":"Decoding Example: Reed-Solomon Codes","text":"println(\"Number of gene encoding barcodes: \", sum(stricter_barcodes.gene .!= \"negative_control\"))\nestimated_false_discovery_rate = sum(stricter_barcodes.gene .== \"negative_control\")*sum(cb.gene .!= \"negative_control\")/sum(cb.gene .== \"negative_control\")/sum(stricter_barcodes.gene .!= \"negative_control\")\nprintln(\"Estimated False Discovery rate: \", estimated_false_discovery_rate)","category":"page"},{"location":"example_decode_RS.html","page":"Decoding Example: Reed-Solomon Codes","title":"Decoding Example: Reed-Solomon Codes","text":"Number of gene encoding barcodes: 1303\nEstimated False Discovery rate: 0.011712467380864363","category":"page"},{"location":"example_decode_RS.html","page":"Decoding Example: Reed-Solomon Codes","title":"Decoding Example: Reed-Solomon Codes","text":"The less strict parameter set decodes about 40% more gene encoding barcodes at a cost of having twice the estimated false discovery rate. Since the estimated false positive rate is still small, it is probably an acceptable trade off.","category":"page"},{"location":"example_decode_RS.html","page":"Decoding Example: Reed-Solomon Codes","title":"Decoding Example: Reed-Solomon Codes","text":"To save your results, use the CSV.write command.","category":"page"},{"location":"example_decode_RS.html","page":"Decoding Example: Reed-Solomon Codes","title":"Decoding Example: Reed-Solomon Codes","text":"CSV.write(\"example_RS_results.csv\", barcodes)","category":"page"},{"location":"example_decode_RS.html","page":"Decoding Example: Reed-Solomon Codes","title":"Decoding Example: Reed-Solomon Codes","text":"\"example_RS_results.csv\"","category":"page"},{"location":"index.html#SeqFISHSyndromeDecoding.jl","page":"SeqFISHSyndromeDecoding.jl","title":"SeqFISHSyndromeDecoding.jl","text":"","category":"section"},{"location":"index.html#Introduction","page":"SeqFISHSyndromeDecoding.jl","title":"Introduction","text":"","category":"section"},{"location":"index.html","page":"SeqFISHSyndromeDecoding.jl","title":"SeqFISHSyndromeDecoding.jl","text":"This package provides functions to decode seqFISH points using syndrome decoding.","category":"page"},{"location":"index.html","page":"SeqFISHSyndromeDecoding.jl","title":"SeqFISHSyndromeDecoding.jl","text":"The main functions are get_codepaths which uses dynamic programming to find barcode candidates and choose_optimal_codepaths which runs an integer programming optimization to choose the best non-conflicting candidates. These functions break the algorithm into two steps because we recommend that users try multiple values for the integer programming objective function parameters, as different values of the parameters will work best for different datasets.","category":"page"},{"location":"index.html#Contents","page":"SeqFISHSyndromeDecoding.jl","title":"Contents","text":"","category":"section"},{"location":"index.html","page":"SeqFISHSyndromeDecoding.jl","title":"SeqFISHSyndromeDecoding.jl","text":"Pages = [\"installation.md\", \"example_decode.md\", \"api_reference.md\"]\nDepth = 3","category":"page"}]
}
